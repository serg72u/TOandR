МОДУЛЬ ОБЫЧНОГО ПРИЛОЖЕНИЯ
 
1.Раздел описания переменных вставить следующий код:
  //=ТОиР==>
Перем глТекущийПользователь Экспорт; 				// В переменной содержится значение
                   									// текущего пользователя данной конфигурации
													
Перем МенеджерЛицензий Экспорт;						// В переменной содержится значение
                									// менеджера лицензий данной конфигурации
													
Перем ИспользоватьМенеджерЛицензий Экспорт; 		// Глобальный флаг:
													// использовать защищенные обработки или нет.
													
Перем ОбработкаЗащитаУправленияРемонтами Экспорт; 	// В переменной содержится значение
												  	// обработки торо_ЗащитаУправлениеРемонтами
										 
Перем ФормаРеакции;										 
Перем ТЗЗаблокированныхОповещений; 				
													
													
//<==ТОиР=


2. В процедуру ПриНачалеРаботыСистемы вставить следующий код:
 
	//=ТОиР==>
	ОткрытьПанельФункций=УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "ОтображатьПанельФункцийТОиР");
	Если ОткрытьПанельФункций И ПравоДоступа("Использование",Метаданные.Обработки.торо_ПанельФункций) Тогда 
			ОбработкаПанельФункций=Обработки.торо_ПанельФункций.Создать();
			ОбработкаПанельФункций.ПолучитьФорму().Открыть();
	КонецЕсли;
	ОткрытьПанельЗадач=УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "ОтображатьПанельЗадачТОиР");
	Если ОткрытьПанельЗадач Тогда 
		ОбработкаПанельФункций=Обработки.торо_ТекущиеЗадачи.Создать();
		ОбработкаПанельФункций.ПолучитьФорму().Открыть();
	КонецЕсли;
	
	//////////	
	ТЗЗаблокированныхОповещений = Новый ТаблицаЗначений;
	ТЗЗаблокированныхОповещений.Колонки.Добавить("ЗаписьРегистра");
	ТЗЗаблокированныхОповещений.Колонки.Добавить("Интервал");	
	
	Если ПравоДоступа("Чтение",Метаданные.Константы.ИнтервалОповещения) И ПравоДоступа("Чтение",Метаданные.Константы.торо_ИспользоватьОповещения) Тогда
		ИнтервалПроверкиОповещенийВСекундах = Константы.ИнтервалОповещения.Получить();
		Если глЗначениеПеременной("глТекущийПользователь") <> Неопределено
			И ТипЗнч(глЗначениеПеременной("глТекущийПользователь")) = Тип("СправочникСсылка.Пользователи")
			И НЕ глЗначениеПеременной("глТекущийПользователь").Пустая()
			И Константы.торо_ИспользоватьОповещения.Получить()
			И ИнтервалПроверкиОповещенийВСекундах > 0 Тогда
			ПодключитьОбработчикОжидания("Напомнить", ИнтервалПроверкиОповещенийВСекундах);
		Иначе
			ОтключитьОбработчикОжидания("Напомнить");
		КонецЕсли; 
	КонецЕсли;
	//////////	
	
	//<==ТОиР=


3. В процедуру ПередНачаломРаботыСистемы вставить следующий код:
		//=ТОиР==>
	Если НЕ РольДоступна("ТОиР")
		И (НЕ РольДоступна("ПолныеПрава")) Тогда 
		Для Каждого Роль Из ПользователиИнформационнойБазы.ТекущийПользователь().Роли Цикл
			Если Найти(Роль.Имя, "торо_") > 0 Тогда
				Отказ = Истина;
				Предупреждение("Вам не назначена роль ""ТОиР"", использование подсистемы ""ТОиР"" невозможно. Запуск конфигурации невозможен.");
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Не Отказ Тогда
		
		ИспользоватьМенеджерЛицензий = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(глЗначениеПеременной("глТекущийПользователь"), "ИспользоватьТОиР");
		Если ИспользоватьМенеджерЛицензий Тогда
			
			ЗапускМенеджераЛицензий();
			
		КонецЕсли;
		
	КонецЕсли; 
	//<==ТОиР=


4. В разделе описания процедур и функций, необходимо вставить следующий код:
//=ТОиР==>

// Процедура выводит  сформированные оповещения для текущего пользователя
//
// Параметры:
//  Нет параметров.
//
Процедура Напомнить() Экспорт
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	торо_СформированныеОповещения.Пользователь,
		|	торо_СформированныеОповещения.ТекстОповещения,
		|	торо_СформированныеОповещения.ФлагРеакции,
		|	торо_СформированныеОповещения.ШапкаОповещения,
		|	торо_СформированныеОповещения.НачалоБлокировки,		
		|	торо_СформированныеОповещения.ОкончаниеБлокировки,
		|	торо_СформированныеОповещения.Дата		
		|ИЗ
		|	РегистрСведений.торо_СформированныеОповещения КАК торо_СформированныеОповещения
		|ГДЕ
		|	торо_СформированныеОповещения.ФлагРеакции = ИСТИНА
		|	И торо_СформированныеОповещения.ОкончаниеБлокировки < &ОкончаниеБлокировки		
		|	И торо_СформированныеОповещения.Пользователь = &Пользователь";		
		
		Запрос.УстановитьПараметр("Пользователь", глЗначениеПеременной("глТекущийПользователь"));
		Запрос.УстановитьПараметр("ОкончаниеБлокировки", ТекущаяДата());		
		Результат = Запрос.Выполнить();
		ТЗВыгрузки = Результат.Выгрузить();
		ВыборкаДетальныеЗаписи = Результат.Выбрать();
        ИндексСтрокиТЗ = 0;
		
		ВычисленноеЗначениеУдаления = Константы.УдалятьОбработанныеОповещенияЧерез.Получить()*86400 - Константы.ИнтервалОповещения.Получить();
		
		Пока ВыборкаДетальныеЗаписи.Следующий()>0 Цикл
			Если ВыборкаДетальныеЗаписи.ФлагРеакции Тогда
				Если (ТекущаяДата() - ВыборкаДетальныеЗаписи.Дата)>= ВычисленноеЗначениеУдаления Тогда
					Рег = РегистрыСведений.торо_СформированныеОповещения.СоздатьМенеджерЗаписи();
					Рег.Дата = ВыборкаДетальныеЗаписи.Дата;
					Рег.Пользователь = ВыборкаДетальныеЗаписи.Пользователь;
					Рег.ШапкаОповещения = ВыборкаДетальныеЗаписи.ШапкаОповещения;
					Рег.ТекстОповещения = ВыборкаДетальныеЗаписи.ТекстОповещения;
					Рег.Прочитать();
					Рег.Удалить();

				КонецЕсли;	
			КонецЕсли;	
		КонецЦикла;	
		
		//Заполнение ТЗ на форме реакции на оповещение выполняется с задержкой в Константы.ИнтервалОповещения по сравнению с
		//удалением из регистра торо_СформированныеОповещения.
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	Оповещения.Пользователь,
		|	Оповещения.ТекстОповещения,
		|	Оповещения.ФлагРеакции,
		|	Оповещения.ШапкаОповещения,
		|	Оповещения.НачалоБлокировки,		
		|	Оповещения.ОкончаниеБлокировки,
		|	Оповещения.Дата		
		|ИЗ
		|	РегистрСведений.торо_СформированныеОповещения КАК Оповещения
		|ГДЕ
		|	Оповещения.ФлагРеакции = ЛОЖЬ
		|	И Оповещения.ОкончаниеБлокировки < &ОкончаниеБлокировки		
		|	И Оповещения.Пользователь = &Пользователь";		
		
		Запрос.УстановитьПараметр("Пользователь", глЗначениеПеременной("глТекущийПользователь"));
		Запрос.УстановитьПараметр("ОкончаниеБлокировки", ТекущаяДата());		
		ТЗВыгрузки = Запрос.Выполнить().Выгрузить();
		
		Если ТЗВыгрузки.Количество()>0 Тогда
			Если ТипЗнч(ФормаРеакции) = Тип("Форма") Тогда
				ФормаРеакции.Оповещения = ТЗВыгрузки;									
				Если ФормаРеакции.Открыта() Тогда
					ФормаРеакции.Активизировать();				
				Иначе
					ФормаРеакции.Открыть();
				КонецЕсли;
			Иначе
				ФормаРеакции = ПолучитьФорму("ОбщаяФорма.торо_ФормаРеакцииНаОповещение");
				ФормаРеакции.Заголовок = "Реакция на оповещение: "+глЗначениеПеременной("глТекущийПользователь");
				ФормаРеакции.Оповещения = ТЗВыгрузки;
				ФормаРеакции.Открыть();
			КонецЕсли;
		Иначе
			Если ТипЗнч(ФормаРеакции) = Тип("Форма") Тогда
				Если ФормаРеакции.Открыта() Тогда
					ФормаРеакции.Закрыть();
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;
	
КонецПроцедуры			

// Функция выполняет запуск менежера лицензий
//
// Параметры:
// Нет.
//
// Возвращаемое значение:
// МенеджерЛицензий   внешняя компонента лицензирования конфигурации.
//
Функция ЗапускМенеджераЛицензий() Экспорт

	Возврат торо_ОбщийМодульСЛК.ПодключитьКомпонентуСЛК();
		
КонецФункции

//Функция выполняет проверку запуска менеджера лицензий ТОиР
//
Функция МенеджерЛицензийТОИРЗапущен() Экспорт

	МенеджерЛицезийЗапущен = Истина;
	
	Если МенеджерЛицензий = Неопределено Тогда
		
		МенеджерЛицезийЗапущен = Ложь;
		
	ИначеЕсли Не(ТипЗнч(МенеджерЛицензий) = Тип("AddIn.Licence.LicenceExtension20")
		И МенеджерЛицензий.Запущен) Тогда
		
		МенеджерЛицезийЗапущен = Ложь;
		
	КонецЕсли;
	
	Если МенеджерЛицезийЗапущен = Ложь Тогда
	
		Возврат ЗапускМенеджераЛицензий();
		
	КонецЕсли;

	Возврат Истина;
	
КонецФункции // МенеджерЛицензийЗапущен()

ИспользоватьМенеджерЛицензий = Ложь;

//<==ТОиР=


МОДУЛЬ УПРАВЛЯЕМОГО ПРИЛОЖЕНИЯ
1. Раздел описания переменных вставить следующий код:
	//=ТОиР==>
	Перем глТекущийПользователь Экспорт; // В переменной содержится значение
	                   // текущего пользователя данной конфигурации

	Перем МенеджерЛицензий Экспорт;	// В переменной содержится значение
	                // менеджера лицензий данной конфигурации

	Перем ИспользоватьМенеджерЛицензий Экспорт; // Глобальный флаг:
												// использовать защищенные обработки или нет.

	Перем ОбработкаЗащитаУправленияРемонтами Экспорт; // В переменной содержится значение

	//<==ТОиР=
2. В процедуру ПередНачаломРаботыСистемы вставить следующий код:
	//=ТОиР==>
	ИспользоватьМенеджерЛицензий = торо_ФормыСерверУправляемый.ПолучитьНастройкуПользователя("ИспользоватьТОиР");
	//ПараметрыСеанса.торо_ПризнакУПП = Истина;
	Если ИспользоватьМенеджерЛицензий Тогда
		ЗапускМенеджераЛицензий();
	КонецЕсли;
	//<==ТОиР=
3. В разделе описания процедур и функций, необходимо вставить следующий код:
	//=ТОиР==>

	// Функция выполняет запуск менежера лицензий
	//
	// Параметры:
	// Нет.
	//
	// Возвращаемое значение:
	// МенеджерЛицензий   внешняя компонента лицензирования конфигурации.
	//
	Функция ЗапускМенеджераЛицензий() Экспорт

		Возврат торо_ОбщийМодульСЛК.ПодключитьКомпонентуСЛК();
		
	КонецФункции

	//Функция выполняет проверку запуска менеджера лицензий ТОиР
	//
	Функция МенеджерЛицензийТОИРЗапущен() Экспорт

		МенеджерЛицезийЗапущен = Истина;
		
		Если МенеджерЛицензий = Неопределено Тогда
			
			МенеджерЛицезийЗапущен = Ложь;
			
		ИначеЕсли Не(ТипЗнч(МенеджерЛицензий) = Тип("AddIn.Licence.LicenceExtension20")
			И МенеджерЛицензий.Запущен) Тогда
			
			МенеджерЛицезийЗапущен = Ложь;
			
		КонецЕсли;
		
		Если МенеджерЛицезийЗапущен = Ложь Тогда
		
			Возврат ЗапускМенеджераЛицензий();
			
		КонецЕсли;

		Возврат Истина;
		
	КонецФункции // МенеджерЛицензийТОИРЗапущен()

	ИспользоватьМенеджерЛицензий = Ложь;

	//<==ТОиР=

МОДУЛЬ СЕАНСА
1. В процедуру УстановкаПараметровСеанса вставить код:
	Если ТребуемыеПараметры = Неопределено Тогда
		// раздел "безусловной" инициализации параметров сеанса
		ПолныеПрава.УстановитьПараметрыМеханизмаОграниченияПравДоступа();
		
		//=> ТОиР
		торо_ПолныеПрава.УстановитьПараметрыМеханизмаОграниченияПравДоступа();
		//<= ТОиР
		
	Иначе
		...

2. В процедуру УстановкаПараметровСеанса, в ветвь Иначе вставить код: 		
		//=> ТОиР
		// СтандартныеПодсистемы
		СтандартныеПодсистемыСервер.УстановкаПараметровСеанса(ТребуемыеПараметры);
		// Конец СтандартныеПодсистемы
		//<= ТОиР


ОБЩИЕ ФОРМЫ
1. В Общую форму ПодборРолейУправляемая.Форма.Модуль

	1. Вставить строчки в функцию 

	&НаСервере
	Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
		
		Заголовок = Параметры.ЗаголовокФормы;
		
		// Роль "Пользователь" нельзя выбрать, она добавляется автоматически
		// Определим есть ли она у пользователя
		ЕстьРольПользователь = (СоставРолей.НайтиСтроки(Новый Структура("ИмяРоли","Пользователь")).Количество() <> 0);
		
		СписокРолейКонфигурации.Загрузить(УправлениеПользователями.ПолучитьСписокРолейКонфигурации(Истина));
		
		//<=ТОиР

		ЕстьРольТОиР = (СоставРолей.НайтиСтроки(Новый Структура("ИмяРоли","ТОиР")).Количество() <> 0);
		ДанныеСписокРолейКонфигурации = СписокРолейКонфигурации.Выгрузить();
		ДанныеДеревоРолейДляВыбора = ДанныеФормыВЗначение(ДеревоРолейДляВыбора, Тип("ДеревоЗначений"));
		
		торо_Интеграция.ДополнитьТаблицуСоответствияРолейГруппам(ДанныеСписокРолейКонфигурации, ДанныеДеревоРолейДляВыбора);
		
		ЗначениеВДанныеФормы(ДанныеСписокРолейКонфигурации, СписокРолейКонфигурации);
		ЗначениеВДанныеФормы(ДанныеДеревоРолейДляВыбора, ДеревоРолейДляВыбора);
		
		//ТОиР=>
		
		ЗаполнитьДеревоРолейДляВыбора(Параметры.СписокРолей);
		
	КонецПроцедуры

	2. Вставить слeдующие строки в процедуру 
	&НаКлиенте
	Процедура ДобавитьВыбранныеРоли()
		
		СоставРолей.Очистить();
		
		// Получим все выбранные роли
		МассивВыбранныхРолей = Новый Массив;
		КоллекцияГруппРолей = ДеревоРолейДляВыбора.ПолучитьЭлементы();
		Для каждого ГруппаРолей Из КоллекцияГруппРолей Цикл
			
			КоллеккцияРолей = ГруппаРолей.ПолучитьЭлементы();
			
			Для каждого ЭлРоль Из КоллеккцияРолей Цикл
				Если ЭлРоль.Пометка <> 1 Тогда
					Продолжить;
				КонецЕсли;
				МассивВыбранныхРолей.Добавить(ЭлРоль.Имя);
			КонецЦикла; 
		КонецЦикла; 
		
		// Роли нужно добавить в порядке ролей конфигурации
		Для каждого РольКонфигурации Из СписокРолейКонфигурации Цикл
			Если МассивВыбранныхРолей.Найти(РольКонфигурации.ИмяРоли) = Неопределено Тогда
				Продолжить;
			КонецЕсли; 
			
			НоваяРоль = СоставРолей.Добавить();
			НоваяРоль.ИмяРоли           = РольКонфигурации.ИмяРоли;
			НоваяРоль.ПредставлениеРоли = РольКонфигурации.ПредставлениеРоли;
			НоваяРоль.Пометка = Истина;
		КонецЦикла;
				
		// Если есть роль Пользователь, то добавим ее в конец списка
		Если ЕстьРольПользователь Тогда
			НоваяРоль = СоставРолей.Добавить();
			НоваяРоль.ИмяРоли           = "Пользователь";
			НоваяРоль.ПредставлениеРоли = "Пользователь";
			НоваяРоль.Пометка = Истина;
		КонецЕсли;
		//<=ТОиР
		//Если есть роль ТОиР, то добавим ее в конец списка
		Если ЕстьРольТОиР Тогда
			НоваяРоль = СоставРолей.Добавить();
			НоваяРоль.ИмяРоли           = "ТОиР";
			НоваяРоль.ПредставлениеРоли = "ТОиР";
			НоваяРоль.Пометка = Истина;
		КонецЕсли;	
		//ТОиР=>
		
		Модифицированность = Ложь;
		
	КонецПроцедуры

	3. Добавить реквизит "ЕстьРольТОиР" типа булево на форму.


ОБЩИЕ МОДУЛИ
1. В Общий модуль БиблиотекаОбновленияИнформационнойБазыПереопределяемый
	в Функция ОбработчикиОбновления() Экспорт	вставить следующие строки

	// Конфигурация ТОиР 
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия    = "*";
	Обработчик.Процедура = "торо_ОбновлениеИнформационнойБазы.ВыполнитьОбновлениеИнформационнойБазы";
	//
2. В Общий модуль УправлениеПользователями
	В ПолучитьСписокРолейКонфигурации(ПолучитьОписаниеРолей = Ложь) Экспорт   заменить следующие строки
	
	Если МетаРоль.Имя = "Пользователь" Тогда
		Продолжить;
	КонецЕсли;

	На

	//<=ТОиР
	Если МетаРоль.Имя = "Пользователь" ИЛИ МетаРоль.Имя = "ТОиР" Тогда
		Продолжить;
	КонецЕсли;
	//ТОиР=>

3. В Общий модуль УправлениеПользователями
	В ЗаполнитьРолиПользователяИБ(ПользовательИБ, СоставРолей) вставить следующие строки

	//<=ТОиР
	//Роль "ТОиР" добавляем автоматически, если есть хотя бы одна роль торо_*
	Если НЕ ПользовательИБ.Роли.Содержит(Метаданные.Роли.ТОиР) Тогда
		МакетОписаниеРолейКонфигурации = ПолучитьОбщийМакет("торо_ОписаниеРолейКонфигурации");
		ОбластьСписокРолей = МакетОписаниеРолейКонфигурации.ПолучитьОбласть("ОписаниеРолей");
		Для Сч = 1 По ОбластьСписокРолей.ВысотаТаблицы Цикл
			Если ПользовательИБ.Роли.Содержит(Метаданные.Роли[ОбластьСписокРолей.Область(Сч,1,Сч,1).Текст]) Тогда
				ПользовательИБ.Роли.Добавить(Метаданные.Роли.ТОиР);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	//ТОиР=>

4. В Общий модуль СтандартныеПодсистемыПереопределяемый,
   в функцию ОбработчикиИнициализацииПараметровСеансаСтандартныхПодсистем добавить строки:

	//=> ТОиР
	// ОбменДанными
	Обработчики.Вставить("ДатаОбновленияПовторноИспользуемыхЗначенийМРО", "ОбменДаннымиСервер.УстановкаПараметровСеанса");
	Обработчики.Вставить("ОбменДаннымиВключен",                           "ОбменДаннымиСервер.УстановкаПараметровСеанса");
	Обработчики.Вставить("ИспользуемыеПланыОбмена",                       "ОбменДаннымиСервер.УстановкаПараметровСеанса");
	Обработчики.Вставить("ПравилаВыборочнойРегистрацииОбъектов",          "ОбменДаннымиСервер.УстановкаПараметровСеанса");
	Обработчики.Вставить("ПравилаРегистрацииОбъектов",                    "ОбменДаннымиСервер.УстановкаПараметровСеанса");
	// Конец ОбменДанными
	//<= ТОиР

5. В Общий модуль ОбщегоНазначенияПовтИсп перенести блок процедур, необходимых для обмена с ОУП

	//=ТОиР==>


	// Возвращает состав общего реквизита с заданным именем.
	//
	// Параметры:
	// Имя - Строка - Имя общего реквизита.
	//
	// Возвращаемое значение:
	// СоставОбщегоРеквизита.
	//
	Функция СоставОбщегоРеквизита(Знач Имя) Экспорт
		
		Возврат Метаданные.ОбщиеРеквизиты[Имя].Состав;
		
	КонецФункции


	// Возвращает объект ПреобразованиеXSL созданный из общего макета с переданным
	// именем.
	//
	// Параметры:
	// ИмяОбщегоМакет - Строка - имя общего макета типа ДвоичныеДанные содержащего
	// файл преобразования XSL.
	//
	// Возвращаемое значение:
	// ПреобразованиеXSL - объект ПреобразованиеXSL.
	//
	Функция ПолучитьПреобразованиеXSLИзОбщегоМакета(Знач ИмяОбщегоМакета) Экспорт
		
		ДанныеМакета = ПолучитьОбщийМакет(ИмяОбщегоМакета);
		ИмяФайлаПреобразования = ПолучитьИмяВременногоФайла("xsl");
		ДанныеМакета.Записать(ИмяФайлаПреобразования);
		
		Преобразование = Новый ПреобразованиеXSL;
		Преобразование.ЗагрузитьИзФайла(ИмяФайлаПреобразования);
		
		Попытка
			УдалитьФайлы(ИмяФайлаПреобразования);
		Исключение
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение XSL'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Возврат Преобразование;
		
	КонецФункции

	// Устарела. Следует использовать коллекцию ЦветаСтиля.
	Функция ЦветСтиля(ИмяЦветаСтиля) Экспорт
		
		Возврат ЦветаСтиля[ИмяЦветаСтиля];
		
	КонецФункции

	// Устарела. Следует использовать коллекцию ШрифтыСтиля.
	Функция ШрифтСтиля(ИмяШрифтаСтиля) Экспорт
		
		Возврат ШрифтыСтиля[ИмяШрифтаСтиля];
		
	КонецФункции

	
	////////////////////////////////////////////////////////////////////////////////
	// СЛУЖЕБНЫЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС

	// Возвращает список полных имен всех объектов метаданных, использующихся в общем реквизите-разделителе,
	//  имя которого передано в качестве значения параметра Разделитель, и значения свойств объекта метаданных,
	//  которые могут потребоваться для дальнейшей его обработки в универсальных алгоритмах.
	// Для последовательностей и журналов документов определяет разделенность по входящим документам: любому из.
	//
	// Параметры:
	//  Разделитель - Строка, имя общего реквизита.
	//
	// Возвращаемое значение:
	// ФиксированноеСоответствие,
	//  Ключ - Строка, полное имя объекта метаданных,
	//  Значение - ФиксированнаяСтруктура,
	//    Имя - Строка, имя объекта метаданных,
	//    Разделитель - Строка, имя разделителя, которым разделен объект метаданных,
	//    УсловноеРазделение - Строка, полное имя объекта метаданных, выступающего в качестве условия использования
	//      разделения объекта метаданных данным разделителем.
	//
	Функция РазделенныеОбъектыМетаданных(Знач Разделитель) Экспорт
		
		Результат = Новый Соответствие;
		
		// I. Перебрать состав всех общих реквизитов.
		
		МетаданныеОбщегоРеквизита = Метаданные.ОбщиеРеквизиты.Найти(Разделитель);
		Если МетаданныеОбщегоРеквизита = Неопределено Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Общий реквизит %1 не обнаружен в конфигурации!'"), Разделитель);
		КонецЕсли;
		
		Если МетаданныеОбщегоРеквизита.РазделениеДанных = Метаданные.СвойстваОбъектов.РазделениеДанныхОбщегоРеквизита.Разделять Тогда
			
			СоставОбщегоРеквизита = ОбщегоНазначенияПовтИсп.СоставОбщегоРеквизита(МетаданныеОбщегоРеквизита.Имя);
			
			ИспользоватьОбщийРеквизит = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Использовать;
			АвтоИспользоватьОбщийРеквизит = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.Авто;
			АвтоИспользованиеОбщегоРеквизита = 
				(МетаданныеОбщегоРеквизита.АвтоИспользование = Метаданные.СвойстваОбъектов.АвтоИспользованиеОбщегоРеквизита.Использовать);
			
			Для Каждого ЭлементСостава Из СоставОбщегоРеквизита Цикл
				
				Если (АвтоИспользованиеОбщегоРеквизита И ЭлементСостава.Использование = АвтоИспользоватьОбщийРеквизит)
					ИЛИ ЭлементСостава.Использование = ИспользоватьОбщийРеквизит Тогда
					
					ДополнительныеДанные = Новый Структура("Имя,Разделитель,УсловноеРазделение", ЭлементСостава.Метаданные.Имя, Разделитель, Неопределено);
					Если ЭлементСостава.УсловноеРазделение <> Неопределено Тогда
						ДополнительныеДанные.УсловноеРазделение = ЭлементСостава.УсловноеРазделение.ПолноеИмя();
					КонецЕсли;
					
					Результат.Вставить(ЭлементСостава.Метаданные.ПолноеИмя(), Новый ФиксированнаяСтруктура(ДополнительныеДанные));
					
					// По регистрам расчета дополнительно определяется разделенность подчиненных им перерасчетов
					Если ОбщегоНазначения.ЭтоРегистрРасчета(ЭлементСостава.Метаданные) Тогда
						
						Перерасчеты = ЭлементСостава.Метаданные.Перерасчеты;
						Для Каждого Перерасчет Из Перерасчеты Цикл
							
							ДополнительныеДанные.Имя = Перерасчет.Имя;
							Результат.Вставить(Перерасчет.ПолноеИмя(), Новый ФиксированнаяСтруктура(ДополнительныеДанные));
							
						КонецЦикла;
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
		Иначе
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Для общего реквизита %1 не используется разделение данных!'"), Разделитель);
			
		КонецЕсли;
		
		// II. Для последовательностей и журналов определять разделенность по входящим документам.
		
		// 1) Последовательности. Перебор с проверкой первого входящего документа. Если документов нет, считаем разделенной.
		Для Каждого МетаданныеПоследовательности Из Метаданные.Последовательности Цикл
			
			ДополнительныеДанные = Новый Структура("Имя,Разделитель,УсловноеРазделение", МетаданныеПоследовательности.Имя, Разделитель, Неопределено);
			
			Если МетаданныеПоследовательности.Документы.Количество() = 0 Тогда
				
				ШаблонСообщения = НСтр("ru = 'В последовательность %1 не включено ни одного документа.'");
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, МетаданныеПоследовательности.Имя);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение разделенных объектов метаданных'", 
					ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), УровеньЖурналаРегистрации.Ошибка, 
					МетаданныеПоследовательности, , ТекстСообщения);
				
				Результат.Вставить(МетаданныеПоследовательности.ПолноеИмя(), Новый ФиксированнаяСтруктура(ДополнительныеДанные));
				
			Иначе
				
				Для Каждого МетаданныеДокумента Из МетаданныеПоследовательности.Документы Цикл
					
					ДополнительныеДанныеОтДокумента = Результат.Получить(МетаданныеДокумента.ПолноеИмя());
					
					Если ДополнительныеДанныеОтДокумента <> Неопределено Тогда
						ЗаполнитьЗначенияСвойств(ДополнительныеДанные, ДополнительныеДанныеОтДокумента, "Разделитель,УсловноеРазделение");
						Результат.Вставить(МетаданныеПоследовательности.ПолноеИмя(), Новый ФиксированнаяСтруктура(ДополнительныеДанные));
					КонецЕсли;
					
					Прервать;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
		// 2) Журналы. Перебор с проверкой первого входящего документа. Если документов нет, считаем разделенным.
		Для Каждого МетаданныеЖурналаДокументов Из Метаданные.ЖурналыДокументов Цикл
			
			ДополнительныеДанные = Новый Структура("Имя,Разделитель,УсловноеРазделение", МетаданныеЖурналаДокументов.Имя, Разделитель, Неопределено);
			
			Если МетаданныеЖурналаДокументов.РегистрируемыеДокументы.Количество() = 0 Тогда
				
				ШаблонСообщения = НСтр("ru = 'В журнал %1 не включено ни одного документа.'");
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, МетаданныеЖурналаДокументов.Имя);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение разделенных объектов метаданных'", 
					ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()), УровеньЖурналаРегистрации.Ошибка, 
					МетаданныеЖурналаДокументов, , ТекстСообщения);
				
				Результат.Вставить(МетаданныеЖурналаДокументов.ПолноеИмя(), Новый ФиксированнаяСтруктура(ДополнительныеДанные));
				
			Иначе
				
				Для Каждого МетаданныеДокумента Из МетаданныеЖурналаДокументов.РегистрируемыеДокументы Цикл
					
					ДополнительныеДанныеОтДокумента = Результат.Получить(МетаданныеДокумента.ПолноеИмя());
					
					Если ДополнительныеДанныеОтДокумента <> Неопределено Тогда
						ЗаполнитьЗначенияСвойств(ДополнительныеДанные, ДополнительныеДанныеОтДокумента, "Разделитель,УсловноеРазделение");
						Результат.Вставить(МетаданныеЖурналаДокументов.ПолноеИмя(), Новый ФиксированнаяСтруктура(ДополнительныеДанные));
					КонецЕсли;
					
					Прервать;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Новый ФиксированноеСоответствие(Результат);
		
	КонецФункции

	////////////////////////////////////////////////////////////////////////////////
	// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

	// Функция получает данные кеша версий из ресурса типа ХранилищеЗначения регистра КэшПрограммныхИнтерфейсов.
	//
	// Параметры:
	// Идентификатор - Строка - идентификатор записи кэша
	// ТипДанных - ПеречислениеСсылка.ТипыДанныхКэшаПрограммныхИнтерфейсов.
	// ПараметрыПолучения - Строка - массив параметров сериализованный в XML для передачи в метод
	//  обновления кэша
	// ВозвращатьУстаревшиеДанные - Булево - флаг определяющий необходимость ожидания обновления
	//  данных в кэше перед возвратом значения, в случае обнаружения факта их устаревания.
	//  Истина - всегда использовать данные из кэша, если они там есть. Ложь - ожидать
	//  обновления данных кэша, в случае обнаружения факта устаревания данных.
	//
	// Возвращаемое значение:
	// Произвольный.
	//
	Функция ПолучитьДанныеКэшаВерсий(Знач Идентификатор, Знач ТипДанных, 
			Знач ПараметрыПолучения, Знач ИспользоватьУстаревшиеДанные = Истина) Экспорт
		
		ПараметрыПолучения = ОбщегоНазначения.ЗначениеИзСтрокиXML(ПараметрыПолучения);
		
		УстановитьПривилегированныйРежим(Истина);
		
		Запрос = Новый Запрос;
		Запрос.Текст =
			"ВЫБРАТЬ
			|	ТаблицаКэша.ДатаОбновления КАК ДатаОбновления,
			|	ТаблицаКэша.Данные КАК Данные,
			|	ТаблицаКэша.ТипДанных КАК ТипДанных
			|ИЗ
			|	РегистрСведений.КэшПрограммныхИнтерфейсов КАК ТаблицаКэша
			|ГДЕ
			|	ТаблицаКэша.Идентификатор = &Идентификатор
			|	И ТаблицаКэша.ТипДанных = &ТипДанных";
		Запрос.УстановитьПараметр("Идентификатор", Идентификатор);
		Запрос.УстановитьПараметр("ТипДанных", ТипДанных);
		
		НачатьТранзакцию();
		Попытка
			// Не устанавливаем управляемую блокировку что бы другие сеансы могли изменять значение пока эта транзакция активна
			Результат = Запрос.Выполнить();
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		ТребуетсяВыполнитьОбновление = Ложь;
		ТребуетсяПеречитатьДанные = Ложь;
		
		Если Результат.Пустой() Тогда
			
			ТребуетсяВыполнитьОбновление = Истина;
			ТребуетсяПеречитатьДанные = Истина;
			
		Иначе
			
			Выборка = Результат.Выбрать();
			Выборка.Следующий();
			Если ОбщегоНазначения.ЗаписьКэшаВерсийУстарела(Выборка) Тогда
				ТребуетсяВыполнитьОбновление = Истина;
				ТребуетсяПеречитатьДанные = НЕ ИспользоватьУстаревшиеДанные;
			КонецЕсли;
		КонецЕсли;
		
		Если ТребуетсяВыполнитьОбновление Тогда
			
			ОбновлениеВТекущемСеансе = ОбщегоНазначения.ИнформационнаяБазаФайловая() ИЛИ МонопольныйРежим();
			
			Если ОбновлениеВТекущемСеансе Тогда
				ОбщегоНазначения.ОбновитьДанныеКэшаВерсий(Идентификатор, ТипДанных, ПараметрыПолучения);
				ТребуетсяПеречитатьДанные = Истина;
			Иначе
				ИмяМетодаЗадания = "ОбщегоНазначения.ОбновитьДанныеКэшаВерсий";
				НаименованиеЗадание = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Обновление кэша версий. Идентификатор записи %1. Тип данных %2.'"),
					Идентификатор,
					ТипДанных);
				ПараметрыЗадания = Новый Массив;
				ПараметрыЗадания.Добавить(Идентификатор);
				ПараметрыЗадания.Добавить(ТипДанных);
				ПараметрыЗадания.Добавить(ПараметрыПолучения);
				
				ОтборЗаданий = Новый Структура;
				ОтборЗаданий.Вставить("ИмяМетода", ИмяМетодаЗадания);
				ОтборЗаданий.Вставить("Наименование", НаименованиеЗадание);
				ОтборЗаданий.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
				
				Задания = ФоновыеЗадания.ПолучитьФоновыеЗадания(ОтборЗаданий);
				Если Задания.Количество() = 0 Тогда
					// Запустим новое
					ФоновыеЗадания.Выполнить(ИмяМетодаЗадания, ПараметрыЗадания, , НаименованиеЗадание);
					// Задание могло сразу завершиться из-за обновления данных другим заданием
					Задания = ФоновыеЗадания.ПолучитьФоновыеЗадания(ОтборЗаданий);
				КонецЕсли;
			КонецЕсли;
			
			Если ТребуетсяПеречитатьДанные Тогда
				Если НЕ ОбновлениеВТекущемСеансе Тогда
					Попытка
						// Дождемся завершения
						ФоновыеЗадания.ОжидатьЗавершения(Задания);
					Исключение
						Для каждого ИсходноеЗадание Из Задания Цикл
							Задание = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ИсходноеЗадание.УникальныйИдентификатор);
							Если Задание.Состояние <> СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
								Продолжить;
							КонецЕсли;
							
							Если Задание.ИнформацияОбОшибке <> Неопределено Тогда
								ЗаписьЖурналаРегистрации(НСтр("ru = 'Обновление кэша версий'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
									УровеньЖурналаРегистрации.Ошибка,
									,
									,
									ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
								ВызватьИсключение(КраткоеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
							Иначе
								ЗаписьЖурналаРегистрации(НСтр("ru = 'Обновление кэша версий'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
									УровеньЖурналаРегистрации.Ошибка,
									,
									,
									ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
								ВызватьИсключение(НСтр("ru = 'Неизвестная ошибка при выполнения задания обновления кэша версий'"));
							КонецЕсли;
						КонецЦикла;
						
						ВызватьИсключение(НСтр("ru = 'Неизвестная ошибка при обновлении кэша версий'"));
					КонецПопытки;
				КонецЕсли;
				
				НачатьТранзакцию();
				Попытка
					// Не устанавливаем управляемую блокировку что бы другие сеансы могли изменять значение пока эта транзакция активна
					Результат = Запрос.Выполнить();
					ЗафиксироватьТранзакцию();
				Исключение
					ОтменитьТранзакцию();
					ВызватьИсключение;
				КонецПопытки;
				
				Если Результат.Пустой() Тогда
					ШаблонСообщения = НСтр("ru = 'Ошибка при обновлении кэша версий. Данные не получены.
						|Идентификатор записи: %1
						|Тип данных: %2'");
					ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						ШаблонСообщения, Идентификатор, ТипДанных);
						
					ВызватьИсключение(ТекстСообщения);
				КонецЕсли;
				
				Выборка = Результат.Выбрать();
				Выборка.Следующий();
			КонецЕсли;
			
		КонецЕсли;
			
		Возврат Выборка.Данные.Получить();
		
	КонецФункции

	// Функция возвращает объект WSОпределения созданный с переданными параметрами.
	//
	// Параметры
	//  АдресWSDL - Строка - месторасположение wsdl
	//  ИмяПользователя - Строка - имя пользователя для входа на сервер
	//  Пароль - Строка - пароль пользователя
	//
	// Примечание: при получении определения используется кэш, обновление которого осуществляется
	//  при смене версии конфигурации. Если для целей отладки требуется обновить
	//  значения в кэше, раньше этого времени, следует удалить из регистра сведений 
	//  КэшПрограммныхИнтерфейсов соответствующие записи.
	//
	Функция WSОпределения(Знач АдресWSDL, Знач ИмяПользователя, Знач Пароль) Экспорт
		
		Возврат ОбщегоНазначения.WSОпределения(АдресWSDL, ИмяПользователя, Пароль);
		
	КонецФункции


	//<==ТОиР=
	

6. В Общем модуле РегламентированнаяОтчетность функция "ИДКонфигурации()" изменить строки

	ИначеЕсли МетаданныеИмя = "УправлениеПроизводственнымПредприятием" Тогда
		Возврат "УПП";
	
	На следующие строки:	
	

	//=> ТОиР
		ИначеЕсли МетаданныеИмя = "УправлениеПроизводственнымПредприятием" ИЛИ МетаданныеИмя = "УправлениеРемонтнымПредприятием" Тогда
			Возврат "УПП";
	//<= ТОиР

7. В Общий модуль ОбменДаннымиКлиент добавить строки:
	//=ТОиР==>
	// Открывает окно выбора файла с правилами
	// и выводит информацию о правилах обмена или правилах регистрации данных пользователю.
	//
	Процедура ПолучитьИнформациюОПравилах(УникальныйИдентификатор) Экспорт
		
		Перем АдресВременногоХранилища;
		Перем СтрокаИнформацииОПравилах;
		
		Отказ = Ложь;
		
		ОбщегоНазначенияКлиент.ПредложитьУстановкуРасширенияРаботыСФайлами();
		
		Если ПодключитьРасширениеРаботыСФайлами()Тогда
			
			// Предложение пользователю выбрать файл правил, по которому требуется получить информацию
			Режим = РежимДиалогаВыбораФайла.Открытие;
			ДиалогОткрытияФайла = Новый ДиалогВыбораФайла(Режим);
			ДиалогОткрытияФайла.ПолноеИмяФайла = "";
			Фильтр = НСтр("ru = 'Файлы правил'") + "(*.xml)|*.xml|";
			ДиалогОткрытияФайла.Фильтр = Фильтр;
			ДиалогОткрытияФайла.МножественныйВыбор = Ложь;
			ДиалогОткрытияФайла.Заголовок = НСтр("ru = 'Укажите файл правил, по которому хотите получить информацию'");
			
			// Если файл выбран - помещаем его в хранилище для последующей загрузки информации из него на сервере
			Если ДиалогОткрытияФайла.Выбрать() Тогда
				ПоместитьФайл(АдресВременногоХранилища, ДиалогОткрытияФайла.ПолноеИмяФайла, , Ложь, УникальныйИдентификатор);
			Иначе
				Возврат;
			КонецЕсли; 
			
		Иначе
			Возврат;
		КонецЕсли;
		
		НСтрока = НСтр("ru = 'Выполняется загрузка информации о правилах...'");
		Состояние(НСтрока);
		
		// загрузка правил на сервере
		ОбменДаннымиСервер.ЗагрузитьИнформациюОПравилах(Отказ, АдресВременногоХранилища, СтрокаИнформацииОПравилах);
		
		Если Отказ Тогда
			
			НСтрока = НСтр("ru = 'При получении информации о правилах возникла ошибка.'");
			
			Предупреждение(НСтрока);
			
		Иначе
			
			ЗаголовокОкна = НСтр("ru = 'Информация о правилах'");
			
			Предупреждение(СтрокаИнформацииОПравилах,, ЗаголовокОкна);
			
		КонецЕсли;
		
	КонецПроцедуры


	// Выполняется проверка дозагрузки сообщения обмена с изменениями конфигурации.
	// Загрузка такого сообщения обмена в подчиненном узле выполняется в два этапа. 
	// Вначале выполняется загрузка изменения конфигурации, затем загрузка данных.
	// Эта функция необходима для реализации сценария, когда загрузка данных 
	// сообщения выполняется перед выполнением обработчиков обновления ИБ.
	//
	// Параметры:
	//  Нет.
	// 
	//  Возвращаемое значение:
	//   Истина – либо загрузка сообщения не требуется, либо загрузка сообщения 
	//   выполнена успешно или отменена; Ложь – загрузка сообщения выполнена с ошибками.
	//
	Функция ПроверитьЗагрузкуСообщенияОбменаСИзменениямиКонфигурацииДляПодчиненногоУзла() Экспорт
		
		Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			Возврат Истина;
		КонецЕсли;
		
		Результат = Истина;
		
		ПараметрыРаботыКлиента = СтандартныеПодсистемыКлиентПовтИсп.ПараметрыРаботыКлиента();
		
		Если  ПараметрыРаботыКлиента.ЭтоПодчиненныйУзелРИБ
			И ПараметрыРаботыКлиента.НеобходимоОбновлениеИнформационнойБазы
			И ПараметрыРаботыКлиента.НастройкаПодчиненногоУзлаРИБЗавершена Тогда
			
			Результат = ОткрытьФормуМодально("ОбщаяФорма.ЗагрузкаСообщенияОбменаСИзменениямиКонфигурации") = Истина;
			
		КонецЕсли;
		
		Если Не Результат Тогда
			
			ЗавершитьРаботуСистемы(Ложь);
			
		КонецЕсли;
		
		Возврат Результат;
	КонецФункции

	//<=ТОиР

8. В Общий модуль ОбменДаннымиПереопределяемый добавить строки:

	//=ТОиР==>

	Процедура ПередЗаписьюОбъекта(Объект, Отказ) Экспорт
		
		//// ДатыЗапретаИзменения
		//ДатыЗапретаИзменения.ВыполнитьПроверкуДатыЗапретаИзменения(Объект, Отказ);
		//// Конец ДатыЗапретаИзменения
		
	КонецПроцедуры

	Процедура ПередОтправкойДанных(СтандартнаяОбработка,
									Получатель,
									ИмяФайлаСообщения,
									ДанныеСообщения,
									КоличествоЭлементовВТранзакции,
									ИмяСобытияЖурналаРегистрации,
									КоличествоОтправленныхОбъектов
		) Экспорт
		
	КонецПроцедуры


	Процедура ПередПолучениемДанных(СтандартнаяОбработка,
									Отправитель,
									ИмяФайлаСообщения,
									ДанныеСообщения,
									КоличествоЭлементовВТранзакции,
									ИмяСобытияЖурналаРегистрации,
									КоличествоПолученныхОбъектов
		) Экспорт
		
	КонецПроцедуры


	Процедура ПослеОпределенияПолучателей(Данные, Получатели, Знач ИмяПланаОбмена) Экспорт
		
		
	КонецПроцедуры

	//<=ТОиР

9. В Общий модуль ОбменДаннымиПовтИсп добавить строки: 	
	
	//=ТОиР==>

	// Только для внутреннего использования
	//
	Процедура ЗаполнитьЗначенияПолейДереваОбъектов(Дерево)
		
		Для Каждого СтрокаДерева Из Дерево Цикл
			
			СтрокаДерева.Идентификатор = ЗначениеВСтрокуВнутр(СтрокаДерева.Ссылка);
			
			Если СтрокаДерева.ЭтоГруппа Тогда
				
				ЗаполнитьЗначенияПолейДереваОбъектов(СтрокаДерева.Строки);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецПроцедуры


	// Возвращает инициализированную обработку КонвертацияОбъектовИнформационныхБаз для выполнения загрузки данных.
	// Обработка сохраняется в платформенном КЭШе для многократного использования для одного узла плана обмена
	// и конкретного файла сообщения обмена с уникальным полным именем.
	//
	// Параметры:
	//  УзелИнформационнойБазы – ПланОбменаСсылка – узел плана обмена
	//  ИмяФайлаСообщенияОбмена - Строка - уникальное имя файла сообщения обмена для загрузки данных
	// 
	//  Возвращаемое значение:
	// Тип: ОбработкаОбъект.КонвертацияОбъектовИнформационныхБаз - инициализированная обработка для загрузки данных
	//
	Функция ОбработкаОбменаДляЗагрузкиДанных(Отказ, УзелИнформационнойБазы, Знач ИмяФайлаСообщенияОбмена) Экспорт
		
		// ИНИЦИАЛИЗАЦИЯ ОБРАБОТКИ ДЛЯ ЗАГРУЗКИ ДАННЫХ
		ОбработкаОбменаДанными = Обработки.КонвертацияОбъектовИнформационныхБаз.Создать();
		
		ОбработкаОбменаДанными.РежимОбмена = "Загрузка";
		
		ОбработкаОбменаДанными.ВыводВОкноСообщенийИнформационныхСообщений = Ложь;
		ОбработкаОбменаДанными.ВыводВПротоколИнформационныхСообщений = Ложь;
		ОбработкаОбменаДанными.ДописыватьДанныеВПротоколОбмена = Ложь;
		ОбработкаОбменаДанными.ВыгружатьТолькоРазрешенные = Ложь;
		ОбработкаОбменаДанными.ФлагРежимОтладки = Ложь;
		
		ОбработкаОбменаДанными.ИмяФайлаПротоколаОбмена = "";
		
		ОбработкаОбменаДанными.КлючСообщенияЖурналаРегистрации = ОбменДаннымиСервер.ПолучитьКлючСообщенияЖурналаРегистрации(УзелИнформационнойБазы, Перечисления.ДействияПриОбмене.ЗагрузкаДанных);
		
		ОбработкаОбменаДанными.УзелОбменаЗагрузкаДанных = УзелИнформационнойБазы;
		ОбработкаОбменаДанными.ИмяФайлаОбмена           = ИмяФайлаСообщенияОбмена;
		
		ОбработкаОбменаДанными.КоличествоОбъектовНаТранзакцию = РегистрыСведений.НастройкиТранспортаОбмена.КоличествоЭлементовВТранзакцииЗагрузкиДанных(УзелИнформационнойБазы);
		
		Возврат ОбработкаОбменаДанными;
		
	КонецФункции

	// Получает объект WSПрокси по настройкам подключения, заданным для узла плана обмена
	// (Только для внутреннего использования)
	//
	Функция ПолучитьWSПроксиДляУзлаИнформационнойБазы(УзелИнформационнойБазы, СтрокаСообщенияОбОшибке = "") Экспорт
		
		СтруктураНастроек = РегистрыСведений.НастройкиТранспортаОбмена.ПолучитьНастройкиТранспортаWS(УзелИнформационнойБазы);
		
		Возврат ОбменДаннымиСервер.ПолучитьWSПроксиПоПараметрамПодключения(СтруктураНастроек, СтрокаСообщенияОбОшибке);
		
	КонецФункции

	// Определяет признак того, то регистрацию изменений объекта следует выполнять с использованием правил регистрации.
	//
	// Параметры:
	//  ИмяПланаОбмена   – Строка – имя плана обмена, как оно задано в конфигураторе.
	//  ПолноеИмяОбъекта – Строка - полное имя объекта метаданных, для которого требуется получить признак использования правил регистрации.
	// 
	Функция РегистрироватьИзмененияПоПравиламРегистрацииОбъекта(Знач ИмяПланаОбмена, Знач ПолноеИмяОбъекта) Экспорт
		
		Если АвтоРегистрацияРазрешена(ИмяПланаОбмена, ПолноеИмяОбъекта) Тогда
			Возврат Ложь;
		ИначеЕсли Не ПравилаРегистрацииОбъектаСуществуют(ИмяПланаОбмена, ПолноеИмяОбъекта) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
	КонецФункции

	//<=ТОиР

10. В Общий модуль ОбменДаннымиСервер добавить строки:

	//=ТОиР==>
	
	Функция WSURLПространстваИменСервиса() Экспорт
		
		Возврат "http://www.1c.ru/SSL/Exchange";
		
	КонецФункции

	Функция WSИмяСервиса() Экспорт
		
		Возврат "Exchange";
		
	КонецФункции

	// Функция возвращает список всех узлов заданного плана обмена кроме предопределенного узла
	//
	// Параметры:
	//  ИмяПланаОбмена – Строка – имя плана обмена, как оно задано в конфигураторе, список узлов для которого необходимо получить
	//
	//  Возвращаемое значение:
	//   Массив – список всех узлов заданного плана обмена.
	//
	Функция ВсеУзлыПланаОбмена(ИмяПланаОбмена) Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		Возврат ОбменДаннымиПовтИсп.ПолучитьМассивУзловПланаОбмена(ИмяПланаОбмена);
		
	КонецФункции

	Процедура ВыполнитьЗагрузкуДляУзлаИнформационнойБазыЧерезФайл(Отказ, Знач ИмяПланаОбмена, Знач КодУзлаИнформационнойБазы, Знач ПолноеИмяФайлаСообщенияОбмена, СтрокаСообщенияОбОшибке = "") Экспорт
		
		ВыполнитьОбменДаннымиДляУзлаИнформационнойБазыЧерезФайлИлиСтроку(Отказ, ИмяПланаОбмена, КодУзлаИнформационнойБазы, ПолноеИмяФайлаСообщенияОбмена,, СтрокаСообщенияОбОшибке, Перечисления.ДействияПриОбмене.ЗагрузкаДанных);
		
	КонецПроцедуры

	// Выполняет обновление типовых правил конвертации объектов для всех планов обмена,
	// для которых созданы настройки обмена в системе
	//
	// Параметры:
	//  Отказ - Булево - флаг отказа; поднимается при возникновении ошибки обновления правил
	// 
	Процедура ВыполнитьОбновлениеТиповыхПравилКонвертацииОбъектов(Отказ)
		
		ВыполнитьОбновлениеВерсииТиповыхПравилДляОбменаДанными(Отказ, "ПравилаКонвертацииОбъектов",);
		
	КонецПроцедуры

	// Выполняет обновление типовых правил регистрации объектов для всех планов обмена,
	// для которых созданы настройки обмена в системе
	//
	// Параметры:
	//  Отказ - Булево - флаг отказа; поднимается при возникновении ошибки обновления правил
	// 
	Процедура ВыполнитьОбновлениеТиповыхПравилРегистрацииОбъектов(Отказ)
		
		ВыполнитьОбновлениеВерсииТиповыхПравилДляОбменаДанными(Отказ, ,"ПравилаРегистрацииОбъектов");
		
	КонецПроцедуры

	Процедура ВыполнитьОбработчикВПривилегированномРежиме(Значение, Знач СтрокаОбработчика) Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		Выполнить(СтрокаОбработчика);
		
	КонецПроцедуры


	Процедура ВыполнитьПроверкуУстановкиВнешнегоСоединения(Отказ, СтруктураНастроек, ОшибкаПодключенияКомпоненты = Ложь) Экспорт
		
		СтрокаСообщенияОбОшибке = "";
		
		// выполняем попытку установки внешнего соединения
		ВнешнееСоединение = УстановитьВнешнееСоединение(СтруктураНастроек, СтрокаСообщенияОбОшибке, ОшибкаПодключенияКомпоненты);
		
		Если ВнешнееСоединение = Неопределено Тогда
			
			// Выводим сообщение об ошибке
			Сообщение = НСтр("ru = 'Ошибка при установке подключения ко второй информационной базе: %1'");
			Сообщение = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Сообщение, СтрокаСообщенияОбОшибке);
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(Сообщение,,,, Отказ);
			
		КонецЕсли;
		
	КонецПроцедуры


	Функция ДобавитьЛетералКИмениФайла(Знач ПолноеИмяФайла, Знач Литерал)
		
		Если ПустаяСтрока(ПолноеИмяФайла) Тогда
			Возврат "";
		КонецЕсли;
		
		ИмяФайлаБезРасширения = Сред(ПолноеИмяФайла, 1, СтрДлина(ПолноеИмяФайла) - 4);
		
		Расширение = Прав(ПолноеИмяФайла, 3);
		
		Результат = "[ИмяФайлаБезРасширения]_[Литерал].[Расширение]";
		
		Результат = СтрЗаменить(Результат, "[ИмяФайлаБезРасширения]", ИмяФайлаБезРасширения);
		Результат = СтрЗаменить(Результат, "[Литерал]",               Литерал);
		Результат = СтрЗаменить(Результат, "[Расширение]",            Расширение);
		
		Возврат Результат;
	КонецФункции


	////////////////////////////////////////////////////////////////////////////////
	// ЭКСПОРТНЫЕ ВНУТРЕННИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

	// Добавляет параметры работы клиентской логики для подсистемы обмена данными
	//
	Процедура ДобавитьПараметрыРаботыКлиентскойЛогикиСтандартныхПодсистем(Параметры) Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		Параметры.Вставить("ЭтоПодчиненныйУзелРИБ", ПланыОбмена.ГлавныйУзел() <> Неопределено);
		Параметры.Вставить("ИмяПланаОбменаРИБ", ?(Параметры.ЭтоПодчиненныйУзелРИБ, ПланыОбмена.ГлавныйУзел().Метаданные().Имя, ""));
		Параметры.Вставить("НастройкаПодчиненногоУзлаРИБЗавершена", Константы.НастройкаПодчиненногоУзлаРИБЗавершена.Получить());
		
	КонецПроцедуры


	// Получает строку информации о правилах конвертации/регистрации из файла правил.
	//
	// Параметры:
	//  АдресВременногоХранилища – адрес временного хранилища, в котором находятся данные файла правил;
	//  СтрокаИнформацииОПравилах – в этот параметр процедура возвращает строку информации о правилах;
	// 
	Процедура ЗагрузитьИнформациюОПравилах(Отказ, АдресВременногоХранилища, СтрокаИнформацииОПравилах) Экспорт
		
		РегистрыСведений.ПравилаДляОбменаДанными.ЗагрузитьИнформациюОПравилах(Отказ, АдресВременногоХранилища, СтрокаИнформацииОПравилах);
		
	КонецПроцедуры


	////////////////////////////////////////////////////////////////////////////////
	// ОБРАБОТЧИКИ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ

	// Добавляет в список Обработчики процедуры-обработчики обновления,
	// необходимые данной подсистеме.
	//
	// Параметры:
	//   Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
	//                                   общего модуля ОбновлениеИнформационнойБазы.
	// 
	Процедура ЗарегистрироватьОбработчикиОбновления(Обработчики) Экспорт
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.Приоритет = 1;
		Обработчик.Процедура = "ОбменДаннымиСервер.ВыполнитьОбновлениеПравилДляОбменаДанными";
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "1.1.1.2";
		Обработчик.Процедура = "ОбменДаннымиСервер.УстановитьНеобходимостьВыполненияКорректировкиИнформацииСопоставленияДляВсехУзловИнформационнойБазы";
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "1.1.1.2";
		Обработчик.Процедура = "ОбменДаннымиСервер.УстановитьРежимВыгрузкиОбъектовДляВсехУзловИнформационнойБазы";
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "1.1.1.2";
		Обработчик.Процедура = "ОбменДаннымиСервер.ОбновитьРегламентныеЗаданияСценариевОбменовДанными";
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "1.1.2.0";
		Обработчик.Процедура = "ОбменДаннымиСервер.ОбновитьКонстантуНастройкаПодчиненногоУзлаРИБЗавершена";
		
	КонецПроцедуры

	Функция ИзмененияЗарегистрированы(УзелИнформационнойБазы) Экспорт
		
		ТекстЗапроса =
		"ВЫБРАТЬ ПЕРВЫЕ 1 1
		|ИЗ
		|	[Таблица].Изменения КАК ТаблицаИзменений
		|ГДЕ
		|	ТаблицаИзменений.Узел = &Узел";
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Узел", УзелИнформационнойБазы);
		
		УстановитьПривилегированныйРежим(Истина);
		
		СоставПланаОбмена = Метаданные.ПланыОбмена[ОбменДаннымиПовтИсп.ПолучитьИмяПланаОбмена(УзелИнформационнойБазы)].Состав;
		
		Для Каждого ЭлементСостава Из СоставПланаОбмена Цикл
			
			Запрос.Текст = СтрЗаменить(ТекстЗапроса, "[Таблица]", ЭлементСостава.Метаданные.ПолноеИмя());
			
			РезультатЗапроса = Запрос.Выполнить();
			
			Если Не РезультатЗапроса.Пустой() Тогда
				Возврат Истина;
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Ложь;
	КонецФункции

	// Возвращает массив узлов плана обмена по заданным параметрам запроса и тексту запроса к таблице плана обмена
	//
	//
	Функция МассивУзловПоЗначениямСвойств(ЗначенияСвойств, Знач ТекстЗапроса, Знач ИмяПланаОбмена, Знач ИмяРеквизитаФлага) Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		// возвращаемое значение функции
		МассивУзловРезультат = Новый Массив;
		
		// подготавливаем запрос для получения узлов планов обмена
		Запрос = Новый Запрос;
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ОбязательныеУсловия]",
					"И    ПланОбменаОсновнаяТаблица.Ссылка <> &" + ИмяПланаОбмена + "ЭтотУзел
					|И НЕ ПланОбменаОсновнаяТаблица.ПометкаУдаления
					|[УсловиеОтбораПоРеквизитуФлагу]
					|");
		//
		Если ПустаяСтрока(ИмяРеквизитаФлага) Тогда
			
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[УсловиеОтбораПоРеквизитуФлагу]", "");
			
		Иначе
			
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[УсловиеОтбораПоРеквизитуФлагу]",
				"И  (ПланОбменаОсновнаяТаблица.[ИмяРеквизитаФлага] = ЗНАЧЕНИЕ(Перечисление.РежимыВыгрузкиОбъектовОбмена.ВыгружатьПоУсловию)
				|ИЛИ ПланОбменаОсновнаяТаблица.[ИмяРеквизитаФлага] = ЗНАЧЕНИЕ(Перечисление.РежимыВыгрузкиОбъектовОбмена.ПустаяСсылка))");
			//
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяРеквизитаФлага]", ИмяРеквизитаФлага);
			
		КонецЕсли;
		
		// текст запроса
		Запрос.Текст = ТекстЗапроса;
		
		Запрос.УстановитьПараметр(ИмяПланаОбмена + "ЭтотУзел", ОбменДаннымиПовтИсп.ПолучитьЭтотУзелПланаОбмена(ИмяПланаОбмена));
		
		// задаем значения параметров запроса из свойств объекта
		Для Каждого Элемент ИЗ ЗначенияСвойств Цикл
			
			Запрос.УстановитьПараметр("СвойствоОбъекта_" + Элемент.Ключ, Элемент.Значение);
			
		КонецЦикла;
		
		Попытка
			
			МассивУзловРезультат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
			
		Исключение
			
			// фиксируем ошибку в ЖР
			
			СтрокаСообщения = НСтр("ru = 'Ошибка при получении списка узлов получателей. Ошибка выполнения запроса: [ОписаниеОшибки]'");
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОписаниеОшибки]", ОписаниеОшибки());
			
			ОбменДаннымиСобытия.ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения);
			
			Возврат Новый Массив // возвращаем пустой массив
			
		КонецПопытки;
		
		// возвращаем результирующий массив узлов
		Возврат МассивУзловРезультат;
		
	КонецФункции

	// Возвращает признак того, что набора записей регистра не содержит данных.
	//
	Функция НаборЗаписейРегистраПустой(СтруктураЗаписи, ИмяРегистра) Экспорт
		
		МетаданныеРегистра = Метаданные.РегистрыСведений[ИмяРегистра];
		
		// создаем набор записей регистра
		НаборЗаписей = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей();
		
		// устанавливаем отбор по измерениям регистра
		Для Каждого Измерение ИЗ МетаданныеРегистра.Измерения Цикл
			
			// если задано значение в структуре, то отбор устанавливаем
			Если СтруктураЗаписи.Свойство(Измерение.Имя) Тогда
				
				НаборЗаписей.Отбор[Измерение.Имя].Установить(СтруктураЗаписи[Измерение.Имя]);
				
			КонецЕсли;
			
		КонецЦикла;
		
		НаборЗаписей.Прочитать();
		
		Возврат НаборЗаписей.Количество() = 0;
		
	КонецФункции

	// Находит регламентное задание по GUID
	//
	// Параметры:
	//  УникальныйНомерЗадания - Строка - строка с GUID регламентного задания
	// 
	// Возвращаемое значение:
	//  Неопределено               - если поиск регламентного задания по GUID не дал результатов
	//  ТекущееРегламентноеЗадание - РегламентноеЗадание - найденное по GUID регламентное задание
	//
	Функция НайтиРегламентноеЗаданиеПоПараметру(УникальныйНомерЗадания) Экспорт
		
		// возвращаемое значение функции
		РегламентноеЗадание = Неопределено;
		
		Если ПустаяСтрока(УникальныйНомерЗадания) Тогда
			
			Возврат Неопределено;
			
		КонецЕсли;
		
		УстановитьПривилегированныйРежим(Истина);
		
		Попытка
			
			РегламентноеЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(УникальныйНомерЗадания));
			
		Исключение
			
			РегламентноеЗадание = Неопределено;
			
		КонецПопытки;
		
		Возврат РегламентноеЗадание;
		
	КонецФункции

	// Признак наличия настроенного обмена данными – определяется по наличию узлов в планах обмена.
	//
	// Параметры:
	//  Нет.
	// 
	//  Возвращаемое значение:
	//  Тип: Булево. Истина – в системе есть настроенный обмен данными; Ложь – обмена нет.
	//
	Функция ОбменДаннымиВключен() Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		Возврат ПараметрыСеанса.ОбменДаннымиВключен;
		
	КонецФункции

	////////////////////////////////////////////////////////////////////////////////
	// ПРОЦЕДУРЫ ОБМЕНА ДАННЫМИ ПОД ПОЛНЫМИ ПРАВАМИ

	// Обновляет/устанавливает повторно-используемые значения и параметры сеанса для подсистемы обмена данными
	//
	// Устанавливаемые параметры сеанса:
	//   ОбменДаннымиВключен         - Булево - флаг, который показывает следует или нет использовать обмен данными в конфигурации.
	//                                Определяется косвенным образом по факту наличия обмена данными хотя бы с одним планом обмена.
	//                                Наличие обмена с каким либо планом обмена определяется по наличию у этого плана обмена узлов
	//                                кроме предопределенного.
	//   ИспользуемыеПланыОбмена    - ФиксированныйМассив - массив с именами планов обмена для которых используется обмен.
	//   ПравилаРегистрацииОбъектов - ХранилищеЗначения - в бинарном виде содержит таблицу значений с правилами регистрации объектов.
	//   ПравилаВыборочнойРегистрацииОбъектов - 
	//   ДатаОбновленияПовторноИспользуемыхЗначенийМРО - Дата (Дата и время) - содержит дату последнего актуального
	//                                                                         кэша для подсистемы обмена данными
	//
	// Параметры:
	//  Нет.
	// 
	Процедура ОбновитьПовторноИспользуемыеЗначенияМРО() Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		// Обновляем повторно используемые значения
		ОбновитьПовторноИспользуемыеЗначения();
		
		// получаем планы обмена конфигурации, которые используются при обмене
		ИспользуемыеПланыОбмена = ПолучитьИспользуемыеПланыОбмена();
		
		// флаг включения механизма обмена данными
		ОбменДаннымиВключен = (ИспользуемыеПланыОбмена.Количество() <> 0);
		
		// устанавливаем параметр сеанса ОбменДаннымиВключен
		ПараметрыСеанса.ОбменДаннымиВключен = ОбменДаннымиВключен;
		
		// устанавливаем параметр сеанса ИспользуемыеПланыОбмена
		ПараметрыСеанса.ИспользуемыеПланыОбмена = Новый ФиксированныйМассив(ИспользуемыеПланыОбмена);
		
		// получаем таблицу правил регистрации из ИБ
		ПравилаРегистрацииОбъектов = ПолучитьПравилаРегистрацииОбъектов();
		
		// устанавливаем параметр сеанса ПравилаРегистрацииОбъектов
		ПараметрыСеанса.ПравилаРегистрацииОбъектов = Новый ХранилищеЗначения(ПравилаРегистрацииОбъектов);
		
		// устанавливаем параметр сеанса ПравилаВыборочнойРегистрацииОбъектов
		ПравилаВыборочнойРегистрацииОбъектов = ПолучитьПравилаВыборочнойРегистрацииОбъектов();
		
		ПараметрыСеанса.ПравилаВыборочнойРегистрацииОбъектов = Новый ХранилищеЗначения(ПравилаВыборочнойРегистрацииОбъектов);
		
		// КЛЮЧ ДЛЯ ПРОВЕРКИ АКТУАЛЬНОСТИ КЭША
		
		// устанавливаем актуальную дату обновления кеша МРО
		АктуальнаяДата = ПолучитьФункциональнуюОпцию("АктуальнаяДатаОбновленияПовторноИспользуемыхЗначенийМРО");
		
		ПараметрыСеанса.ДатаОбновленияПовторноИспользуемыхЗначенийМРО = АктуальнаяДата;
		
	КонецПроцедуры

	// Выполняет проверку актуальности КЭШа механизма регистрации объектов.
	// Если кэш неактуальный, то выполняется инициализация КЭШа актуальными значениями.
	//
	// Параметры:
	//  Нет.
	// 
	Процедура ОбновитьПовторноИспользуемыеЗначенияМРОПриНеобходимости() Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		Если ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
			
			АктуальнаяДата = ПолучитьФункциональнуюОпцию("АктуальнаяДатаОбновленияПовторноИспользуемыхЗначенийМРО");
			
			Если ПараметрыСеанса.ДатаОбновленияПовторноИспользуемыхЗначенийМРО <> АктуальнаяДата Тогда
				
				ОбновитьПовторноИспользуемыеЗначенияМРО();
				
				// рекурсивный вызов для проверки
				ОбновитьПовторноИспользуемыеЗначенияМРОПриНеобходимости();
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецПроцедуры

	Процедура ОбработчикПередОтправкойДанных(СтандартнаяОбработка,
												Знач Получатель,
												Знач ИмяФайлаСообщения,
												ДанныеСообщения,
												Знач КоличествоЭлементовВТранзакции,
												Знач ИмяСобытияЖурналаРегистрации,
												КоличествоОтправленныхОбъектов
		)
		
		ОбменДаннымиПереопределяемый.ПередОтправкойДанных(СтандартнаяОбработка,
												Получатель,
												ИмяФайлаСообщения,
												ДанныеСообщения,
												КоличествоЭлементовВТранзакции,
												ИмяСобытияЖурналаРегистрации,
												КоличествоОтправленныхОбъектов
		);
		
	КонецПроцедуры

	Процедура ОбработчикПередПолучениемДанных(СтандартнаяОбработка,
												Знач Отправитель,
												Знач ИмяФайлаСообщения,
												ДанныеСообщения,
												Знач КоличествоЭлементовВТранзакции,
												Знач ИмяСобытияЖурналаРегистрации,
												КоличествоПолученныхОбъектов
		)
		
		ОбменДаннымиПереопределяемый.ПередПолучениемДанных(СтандартнаяОбработка,
												Отправитель,
												ИмяФайлаСообщения,
												ДанныеСообщения,
												КоличествоЭлементовВТранзакции,
												ИмяСобытияЖурналаРегистрации,
												КоличествоПолученныхОбъектов
		);
		
	КонецПроцедуры

	// Возвращает значение параметра сеанса ПравилаРегистрацииОбъектов, полученное в привилегированном режиме.
	//
	// Параметры:
	//  Нет.
	// 
	//  Возвращаемое значение:
	//  Тип: ХранилищеЗначения. Значение параметра сеанса ПравилаРегистрацииОбъектов.
	//
	Функция ПараметрыСеансаПравилаРегистрацииОбъектов() Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		
		Возврат ПараметрыСеанса.ПравилаРегистрацииОбъектов;
		
	КонецФункции

	// Возвращает структуру со значениями свойств объекта, полученных запросом из ИБ.
	// Ключ структуры – имя свойства; Значение – значение свойства объекта.
	//
	// Параметры:
	//  Ссылка – ссылка на объект ИБ, значения свойств которого требуется получить
	// 
	//  Возвращаемое значение:
	//  Тип: Структура. Структура со значениями свойств объекта.
	//
	Функция ПолучитьЗначенияСвойствДляСсылки(Ссылка, СвойстваОбъекта, Знач СвойстваОбъектаСтрокой, Знач ОбъектМетаданныхИмя) Экспорт
		
		ЗначенияСвойств = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(СвойстваОбъекта);
		
		Если ЗначенияСвойств.Количество() = 0 Тогда
			
			Возврат ЗначенияСвойств; // возвращаем пустую структуру
			
		КонецЕсли;
		
		ТекстЗапроса = "
		|ВЫБРАТЬ
		|	[СвойстваОбъектаСтрокой]
		|ИЗ
		|	[ОбъектМетаданныхИмя] КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка
		|";
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[СвойстваОбъектаСтрокой]", СвойстваОбъектаСтрокой);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ОбъектМетаданныхИмя]",    ОбъектМетаданныхИмя);
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Ссылка);
		
		УстановитьПривилегированныйРежим(Истина);
		
		Попытка
			
			Выборка = Запрос.Выполнить().Выбрать();
			
		Исключение
			
			// фиксируем ошибку в ЖР
			СтрокаСообщения = НСтр("ru = 'Ошибка при получении свойств ссылки. Ошибка выполнения запроса: [ОписаниеОшибки]'");
			СтрокаСообщения = СтрЗаменить(СтрокаСообщения, "[ОписаниеОшибки]", ОписаниеОшибки());
			ОбменДаннымиСобытия.ЗаписьЖурналаРегистрацииПРО(СтрокаСообщения, Ссылка.Метаданные());
			
			// устанавливаем все свойства в значение "Неопределено"
			Для Каждого Элемент ИЗ ЗначенияСвойств Цикл
				
				ЗначенияСвойств[Элемент.Ключ] = Неопределено;
				
			КонецЦикла;
			
			Возврат ЗначенияСвойств;
		КонецПопытки;
		
		Если Выборка.Следующий() Тогда
			
			Для Каждого Элемент ИЗ ЗначенияСвойств Цикл
				
				ЗначенияСвойств[Элемент.Ключ] = Выборка[Элемент.Ключ];
				
			КонецЦикла;
			
		КонецЕсли;
		
		Возврат ЗначенияСвойств;
		
	КонецФункции

	// Возвращает ключ сообщения журнала регистрации по строке действия
	//
	Функция ПолучитьКлючСообщенияЖурналаРегистрацииПоСтрокеДействия(УзелИнформационнойБазы, ДействиеПриОбменеСтрокой) Экспорт
		
		Возврат ПолучитьКлючСообщенияЖурналаРегистрации(УзелИнформационнойБазы, Перечисления.ДействияПриОбмене[ДействиеПриОбменеСтрокой]);
		
	КонецФункции

	// Получает массив узлов плана обмена, для которых установлен признак «Выгружать всегда»
	//
	// Параметры:
	//  ИмяПланаОбмена    – Строка – имя плана обмена, как объекта метаданных, по которому определяются узлы
	//  ИмяРеквизитаФлага – Строка – имя реквизита плана обмена, по которому устанавливается фильтр на выборку узлов 
	// 
	//  Возвращаемое значение:
	//  Тип: Массив. Массив узлов плана обмена, для которых установлен признак «Выгружать всегда»
	//
	Функция ПолучитьМассивУзловДляРегистрацииВыгружатьВсегда(Знач ИмяПланаОбмена, Знач ИмяРеквизитаФлага) Экспорт
		
		ТекстЗапроса = "
		|ВЫБРАТЬ
		|	ШапкаПланаОбмена.Ссылка КАК Узел
		|ИЗ
		|	ПланОбмена.[ИмяПланаОбмена] КАК ШапкаПланаОбмена
		|ГДЕ
		|	  ШапкаПланаОбмена.Ссылка <> &ЭтотУзел
		|	И ШапкаПланаОбмена.[ИмяРеквизитаФлага] = ЗНАЧЕНИЕ(Перечисление.РежимыВыгрузкиОбъектовОбмена.ВыгружатьВсегда)
		|	И Не ШапкаПланаОбмена.ПометкаУдаления
		|";
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяПланаОбмена]",    ИмяПланаОбмена);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяРеквизитаФлага]", ИмяРеквизитаФлага);
		
		УстановитьПривилегированныйРежим(Истина);
		
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ЭтотУзел", ОбменДаннымиПовтИсп.ПолучитьЭтотУзелПланаОбмена(ИмяПланаОбмена));
		Запрос.Текст = ТекстЗапроса;
		
		Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Узел");
		
	КонецФункции

	// Получает массив узлов плана обмена, для которых установлен признак «Выгружать при необходимости»
	//
	// Параметры:
	//  Ссылка – ссылка на объект ИБ, для которого необходимо получить массив узлов, в которые объект ранее выгружался
	//  ИмяПланаОбмена    – Строка – имя плана обмена, как объекта метаданных, по которому определяются узлы
	//  ИмяРеквизитаФлага – Строка – имя реквизита плана обмена, по которому устанавливается фильтр на выборку узлов 
	// 
	//  Возвращаемое значение:
	//  Тип: Массив. Массив узлов плана обмена, для которых установлен признак «Выгружать при необходимости»
	//
	Функция ПолучитьМассивУзловДляРегистрацииВыгружатьПриНеобходимости(Ссылка, Знач ИмяПланаОбмена, Знач ИмяРеквизитаФлага) Экспорт
		
		ТекстЗапроса = "
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ШапкаПланаОбмена.Ссылка КАК Узел
		|ИЗ
		|	ПланОбмена.[ИмяПланаОбмена] КАК ШапкаПланаОбмена
		|ЛЕВОЕ СОЕДИНЕНИЕ
		|	РегистрСведений.СоответствияОбъектовИнформационныхБаз КАК СоответствияОбъектовИнформационныхБаз
		|ПО
		|	ШапкаПланаОбмена.Ссылка = СоответствияОбъектовИнформационныхБаз.УзелИнформационнойБазы
		|	И СоответствияОбъектовИнформационныхБаз.УникальныйИдентификаторИсточника = &Объект
		|ГДЕ
		|	     ШапкаПланаОбмена.Ссылка <> &ЭтотУзел
		|	И    ШапкаПланаОбмена.[ИмяРеквизитаФлага] = ЗНАЧЕНИЕ(Перечисление.РежимыВыгрузкиОбъектовОбмена.ВыгружатьПриНеобходимости)
		|	И НЕ ШапкаПланаОбмена.ПометкаУдаления
		|	И    СоответствияОбъектовИнформационныхБаз.УникальныйИдентификаторИсточника = &Объект
		|";
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяПланаОбмена]",    ИмяПланаОбмена);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяРеквизитаФлага]", ИмяРеквизитаФлага);
		
		УстановитьПривилегированныйРежим(Истина);
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("ЭтотУзел", ОбменДаннымиПовтИсп.ПолучитьЭтотУзелПланаОбмена(ИмяПланаОбмена));
		Запрос.УстановитьПараметр("Объект",   Ссылка);
		
		Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Узел");
		
	КонецФункции

	// Возвращает структуру с данными отбора для журнала регистрации
	//
	Функция ПолучитьСтруктуруДанныхОтбораЖурналаРегистрации(УзелИнформационнойБазы, Знач ДействиеПриОбмене) Экспорт
		
		Если ТипЗнч(ДействиеПриОбмене) = Тип("Строка") Тогда
			
			ДействиеПриОбмене = Перечисления.ДействияПриОбмене[ДействиеПриОбмене];
			
		КонецЕсли;
		
		СостоянияОбменовДанными = РегистрыСведений.СостоянияОбменовДанными.СостоянияОбменовДанными(УзелИнформационнойБазы, ДействиеПриОбмене);
		
		Отбор = Новый Структура;
		Отбор.Вставить("СобытиеЖурналаРегистрации", ПолучитьКлючСообщенияЖурналаРегистрации(УзелИнформационнойБазы, ДействиеПриОбмене));
		Отбор.Вставить("ДатаНачала",                СостоянияОбменовДанными.ДатаНачала);
		Отбор.Вставить("ДатаОкончания",             СостоянияОбменовДанными.ДатаОкончания);
		
		Возврат Отбор;
	КонецФункции

	// Возвращает признак доступности роли "ПолныеПрава" или "ДобавлениеИзменениеОбменовДанными"
	//
	Функция РольДоступнаДобавлениеИзменениеОбменовДанными() Экспорт
		
		Возврат РольДоступна(Метаданные.Роли.ПолныеПрава)
			ИЛИ РольДоступна(Метаданные.Роли.ДобавлениеИзменениеОбменовДанными);
		
	КонецФункции

	// Устанавливает значение константы ДатаОбновленияПовторноИспользуемыхЗначенийМРО
	// В качестве устанавливаемого значения используется текущая дата компьютера (сервера)
	// В момент изменения значения этой константы повторно-используемые значения 
	// для подсистемы обмена данными становятся не актуальными и требуют повторной инициализации.
	//
	// Параметры:
	//  Нет.
	// 
	Процедура УстановитьДатуОбновленияПовторноИспользуемыхЗначенийМРО() Экспорт
		
		УстановитьПривилегированныйРежим(Истина);
		// записываем дату и время компьютера сервера - ТекущаяДата()
		Константы.ДатаОбновленияПовторноИспользуемыхЗначенийМРО.Установить(ТекущаяДата());
		
	КонецПроцедуры

	// Устанавливает параметры сеанса подсистемы обмена данными
	//
	// Параметры:
	//  ИмяПараметра - Строка - имя параметра сеанса, значение которого необходимо установить
	//  УстановленныеПараметры - массив - в данный параметр помещается информация об установленных параметрах сеанса
	// 
	Процедура УстановкаПараметровСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт
		
		// процедура обновления повторно-используемых значений и параметров сеанса
		ОбновитьПовторноИспользуемыеЗначенияМРО();
		
		// зарегистрируем имена параметров, которые установлены при 
		// выполнении ОбновитьПовторноИспользуемыеЗначенияМРО
		УстановленныеПараметры.Добавить("ОбменДаннымиВключен");
		УстановленныеПараметры.Добавить("ИспользуемыеПланыОбмена");
		УстановленныеПараметры.Добавить("ПравилаВыборочнойРегистрацииОбъектов");
		УстановленныеПараметры.Добавить("ПравилаРегистрацииОбъектов");
		УстановленныеПараметры.Добавить("ДатаОбновленияПовторноИспользуемыхЗначенийМРО");
		
	КонецПроцедуры

	//<=ТОиР	

11. В Общий модуль "ОбменДаннымиСобытия" добавить строки:

	//=ТОиР==>

	Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора)
		
		Таблица.Колонки.Добавить("ИтераторТаблицыРеквизитовРегистрации");
		
		Таблица.ЗаполнитьЗначения(ЗначениеИтератора, "ИтераторТаблицыРеквизитовРегистрации");
		
	КонецПроцедуры

	////////////////////////////////////////////////////////////////////////////////
	// ПРОЦЕДУРЫ РАБОТЫ С ЖУРНАЛОМ РЕГИСТРАЦИИ

	// Добавляет одну запись в журнал регистрации для подсистемы правил регистрации объектов.
	//
	Процедура ЗаписьЖурналаРегистрацииПРО(Комментарий, ОбъектМетаданных = Неопределено) Экспорт
		
		ЗаписьЖурналаРегистрации("Обмен данными.Правила регистрации объектов", УровеньЖурналаРегистрации.Ошибка, ОбъектМетаданных, , Комментарий);
		
	КонецПроцедуры

	//

	// Только для внутреннего использования
	//
	Процедура ПередПроверкойЗапретаИзменения(Объект, СтандартнаяОбработка, УзелПланаОбмена, СообщитьОЗапрете) Экспорт
		
		Если Объект.ДополнительныеСвойства.Свойство("НеПроверятьДатыЗапретаИзмененияДанных") Тогда
			
			СтандартнаяОбработка = Ложь;
			
		ИначеЕсли Объект.ОбменДанными.Загрузка Тогда
			
			Отправитель = Объект.ОбменДанными.Отправитель;
			
			Если Отправитель = Неопределено Тогда
				
				Объект.ДополнительныеСвойства.Свойство("ОбменДанными_Отправитель", Отправитель);
				
			КонецЕсли;
			
			Если Отправитель <> Неопределено Тогда
				
				Если ОбменДаннымиПовтИсп.ЭтоУзелРаспределеннойИнформационнойБазы(Отправитель) Тогда
					
					// Проверку на даты запрета изменения при обмене в РИБ не выполняем
					СтандартнаяОбработка = Ложь;
					
				Иначе
					
					СтандартнаяОбработка = Ложь;
					
					УзелПланаОбмена = Отправитель;
					
					СообщитьОЗапрете = Ложь;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецПроцедуры

	//<=ТОиР

12. В Общий модуль "ОбщегоНазначенияПереопределяемый" добавить строки: 
	 
	//=ТОиР==>

	Функция ВернутьСписокТиповОбъектовДляФормированияФИО() Экспорт
		
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(Тип("СправочникОбъект.ФизическиеЛица"));
		МассивТипов.Добавить(Тип("СправочникОбъект.СотрудникиОрганизаций"));
		
		Возврат Новый ОписаниеТипов(МассивТипов);
		
	КонецФункции


	Функция ВернутьСписокТиповСсылокДляФормированияФИО() Экспорт
		
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(Тип("СправочникСсылка.ФизическиеЛица"));
		МассивТипов.Добавить(Тип("СправочникСсылка.СотрудникиОрганизаций"));
		
		Возврат Новый ОписаниеТипов(МассивТипов);
		
	КонецФункции

	// Проверяет правильность заполнения КПП
	//
	// Возвращаемое значение:
	//   Булево
	//
	Функция КППОрганизацииСоответствуетТребованиям(КПП, ТекстСообщенияОшибки) Экспорт
		
		Возврат Истина;

	КонецФункции // КППОрганизацииСоответствуетТребованиям()

	// Возвращает соответствие имен параметров сеанса и обработчиков для их инициализации.
	//
	Функция ОбработчикиИнициализацииПараметровСеанса() Экспорт
		
		// Для задания обработчиков параметров сеанса следует использовать шаблон:
		// Обработчики.Вставить("<ИмяПараметраСеанса>|<НачалоИмениПараметраСеанса*>", "Обработчик");
		//
		// Примечание. Символ '*'используется в конце имени параметра сеанса и обозначает,
		//             что один обработчик будет вызван для инициализации всех параметров сеанса
		//             с именем, начинающимся на слово НачалоИмениПараметраСеанса
		//
		
		Обработчики = Новый Соответствие;
		
		Возврат Обработчики;
		
	КонецФункции

	// Проверяет правильность заполнения ОГРН
	// Возвращаемое значение:
	//   Булево
	//
	Функция ОГРНСоответствуетТребованиям(ОГРН, ЮрФизЛицо, ТекстСообщенияОшибки) Экспорт
		
		Возврат Истина;

	КонецФункции // ОГРНСоответствуетТребованиям()

	// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
	//

	// Определяет есть ли денежные показатели с незаполненной валютой
	//
	Функция ОпределитьНаличиеВалютныхПоказателей()
		
		Возврат Ложь;
		
	КонецФункции

	Функция ПолучитьЗначениеПеременной(ИмяПараметраВР, НайденноеЗначение, Кэш, ПоместитьВКэш) Экспорт
		
		Если ИмяПараметраВР = ВРег("глУчетнаяПолитикаПоПерсоналу") Тогда
			
			НайденноеЗначение = Неопределено;
					
		ИначеЕсли ИмяПараметраВР = ВРег("глИспользоватьУправленческийУчетЗарплаты") Тогда
			
			НайденноеЗначение = Ложь;
			
		ИначеЕсли ИмяПараметраВР = ВРег("глЕстьВалютныеПоказатели") Тогда
			
			НайденноеЗначение = ОпределитьНаличиеВалютныхПоказателей();
					
		ИначеЕсли ИмяПараметраВР = ВРег("глВалютаУправленческогоУчета") Тогда

			НайденноеЗначение = Неопределено;
					
		КонецЕсли;
		
		Возврат НайденноеЗначение;
		
	КонецФункции

	// Возвращает список имен объектов метаданных, данные которых могут содержать ссылки на различные объекты метаданных,
	// но при этом эти ссылки не должны учитываться в бизнес-логике приложения.
	//
	// Пример:
	// Для документ "Реализация товаров и услуг" настроена подсистема версионирования объектов,
	// и подсистема свойств. При этом на экземпляр документа может быть множество ссылок 
	// в информационной базе (из других документов, регистров). Часть ссылок имеют значение для бизнес-логики
	// (например движения по регистрам). Другая часть ссылок - "техногенные" ссылки на объект из объектов ИБ,
	// которые относятся к подсистеме версионирования объектов и подсистеме свойств. Такие "техногенные"
	// ссылки должны быть отфильтрованы, например, в обработке удаления помеченных и при поиске ссылок на объект
	// в подсистеме запрета редактирования ключевых реквизитов.
	// Список таких "техногенных" объектов нужно перечислить в этой функции.
	//
	// Возвращаемое значение:
	//  Массив       - массив строк, например, "РегистрСведений.ВерсииОбъектов".
	//
	Функция ПолучитьИсключенияПоискаСсылок() Экспорт
		
		Массив = Новый Массив;
		
		Возврат Массив;
		
	КонецФункции 

	// Устанавливает текстовое описание предмета
	//
	// Параметры
	//  СсылкаНаПредмет  – ЛюбаяСсылка – объект ссылочного типа.
	//  Представление	 - Строка - сюда необходимо поместить текстовое описание.
	Процедура УстановитьПредставлениеПредмета(СсылкаНаПредмет, Представление) Экспорт
		
	КонецПроцедуры

	Функция ЭтоЮрЛицо(Организация) Экспорт
		
		Возврат (Ложь);
		
	КонецФункции // ЭтоЮрЛицо()

	//<=ТОиР

СПРАВОЧНИКИ
Справочники.Пользователи.Форма.ФормаРедактированиеПользователяИБ.Модуль
	1. В Процедура ЗаписатьПользователяИБ(Отказ, ТекущийОбъект) добавить строки
	//<=ТОиР
	//Роль "ТОиР" добавляем автоматически, если есть хотя бы одна роль торо_*
	Если СписокРолей.Найти("ТОиР", "ИмяРоли") = Неопределено Тогда
		МакетОписаниеРолейКонфигурации = ПолучитьОбщийМакет("торо_ОписаниеРолейКонфигурации");
		ОбластьСписокРолей = МакетОписаниеРолейКонфигурации.ПолучитьОбласть("ОписаниеРолей");
		Для Сч = 1 По ОбластьСписокРолей.ВысотаТаблицы Цикл
			Если СписокРолей.Найти(ОбластьСписокРолей.Область(Сч,1,Сч,1).Текст, "ИмяРоли") <> Неопределено Тогда
				НоваяСтрока = СписокРолей.Добавить();
				НоваяСтрока.ИмяРоли = "ТОиР";
				НоваяСтрока.Пометка = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	//ТОиР=>
	2. В УдалитьВыбранныеРоли() заменить строки

	Если РольОбъекта.ИмяРоли = "Пользователь" Тогда
		// Роль "Пользователь" нельзя удалять
		Продолжить;
	КонецЕсли;

	На	
	
	//<=ТОиР
	Если РольОбъекта.ИмяРоли = "Пользователь" ИЛИ РольОбъекта.ИмяРоли = "ТОиР" Тогда
		// Роли "Пользователь" и "ТОиР" нельзя удалять
		Продолжить;
	КонецЕсли;
	//ТОиР=>
	3. В Процедура ЗаполнитьСписокРолейПользователяИБ(Знач ПользовательИБ = Неопределено)  вставить строки
	//<=ТОиР
	Если РольПользователя.Имя = "ТОиР" Тогда
		// Роль "ТОиР" не показываем в списке
		// Предполагается, что она есть у всех пользователей, имеющих одну из ролей торо_*
		Продолжить;
	КонецЕсли;	
	//ТОиР=>


